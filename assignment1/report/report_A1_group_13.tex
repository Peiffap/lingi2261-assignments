\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[top=2cm, bottom=2cm,left=2cm,right=2cm]{geometry}
\usepackage{minted}

\newcommand{\py}[1]{\mintinline{python}{#1}}

\title{LINGI2261 -- Assignment 1 of group 13}
\author{Martin Braquet \and Gilles Peiffer}

\begin{document}

\maketitle

\section{Python AIMA}

\begin{enumerate}
 \item The main class, \py{Problem}, is a very general class. We thus have to subclass it in order to adapt it for our specific problems. The methods requiring a specific implementation are detailed below:
 
 \begin{itemize}
  \item \py{__init__} allows the user to define a goal state, if it is unique.
  Other arguments can also be added in the class.
  \item \py{successor} returns a sequence of (action, state) pairs reachable from a specific state.
  \item \py{goal_test} determines when the search algorithm must stop.
  \item \py{path_cost} is used to assess the cost of each path, determining the optimality of the solution.
 \end{itemize}
 After that, we need to create instances of our new subclass and solve them with the interesting search functions available in \texttt{search.py}.
 \item The \py{tree_search} method tries to find a solution by taking as arguments the problem to solve and an empty frontier, for which the fundamental difference is the type of this list.
 Indeed, \py{breadth_first_graph_search} uses a LIFO queue to store the nodes of the frontier in order to search the shallowest nodes first, while the \py{depth_first_graph_search} uses a FIFO queue in order to search the deepest nodes first.
 \item There are two involved methods detailed hereinafter.
 \begin{itemize}
 	\item \py{node.expand(problem)} is a method from the \py{Node} class that outputs a list of the successors of the node given as argument.
 	\item \py{fringe.extend(node.expand(problem))} is a method from the \py{List} class that appends the list of nodes onto the list of nodes in the frontier (fringe).
 \end{itemize}
 \item The \py{graph_search} method keeps track of all the visited states (as well as the states in the frontier).
 Although it requires more memory to store these states, this method has the advantage of dropping new nodes containing a state that has already been visited.
 Considering this main advantage, the graph search makes the depth-first search complete for finite state spaces and bounds the space and time complexities by the size of the state space, which is not the case for the tree search (it is not complete and the complexities are bounded by the tree size).
 \item The \py{closed} list is a dictionary. Dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. In \py{search.py}, the keys of \py{closed} are the states of the problem and the values of \py{closed} are always \py{True}. In the template of this problem, the state is represented by a 2D array of characters (a knight or a blank space), as well as other integer parameters. The 2D array is a list and is mutable, the state class is thus mutable and cannot be used for by the search from the dictionary closed. 
 \item % :'(
\end{enumerate}


\section{The Knightâ€™s tour Problem}

\begin{enumerate}
 \item The knight can move on at most 8 different tiles per move. The branching factor is thus $b = 8$.
 \item The number of tiles is $n_{cols} \times n_{rows} = 25$ in the template board, meaning that the tree is not so deep compare to the breadth.
 \begin{itemize}
  \item A breadth first search in this case is not so efficient because the branching factor is quite large. Because the number of moves is the same for a given chess board, we are sure that the depth of the solution is the same for all initial positions: $d = n_{cols} \times n_{rows} - 1$. This information leads us to an easy \py{goal_test}, we can simply check that the number of busy tiles (given as a paramer of the \py{state} class) is equal to $d$. The graph search requires too many computations to check if a new state has already been visited. Thus, the tree search is more efficient (at least for now, without improvement of the code...).
  \item 
 \end{itemize}
 \item 
 \item Some instances are highly dependent of the order of the successors.
 
 

\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
 \hline
  & DFSt [s] & BFSt [s] & DFSg [s] & DFSg [s]\\
 \hline 
 1 & 5.075 & 32 & & \\ 
 \hline 
 2 & 0.504 & 38 & & \\ 
 \hline 
 3 & 4.633 & 34 & & \\ 
 \hline 
 4 & 5.650 & 33 & & \\ 
 \hline 
 5 & 0.401 & & & \\ 
 \hline 
 6 & 0.238 & & & \\ 
 \hline 
 7 & 7.485 & & & \\ 
 \hline 
 8 & 0.871 & & & \\ 
 \hline 
 9 & 0.818 & & & \\ 
 \hline 
 10 & 3.129 & & & \\ 
 \hline
\end{tabular}
\end{center}



 \item 
 \item Bidirectionnal search, iterative deepening with limit.
\end{enumerate}


\end{document}

